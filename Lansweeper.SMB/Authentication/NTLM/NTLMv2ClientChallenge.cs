using System.Text;
using Lansweeper.Smb.Utilities;

namespace Lansweeper.Smb.Authentication.NTLM;

/// <summary>
///     NTLMv2_CLIENT_CHALLENGE
///     
///                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
///    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
///   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
///   |    RespType   |  HiRespType   |           Reserved1           |
///   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
///   |                           Reserved2                           |
///   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
///   |                                                               |
///   /                       TimeStamp (8 bytes)                     /
///   |                                                               |
///   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
///   |                                                               |
///   /                        ClientChallenge                        /
///   |                                                               |
///   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
///   |                           Reserved3                           |
///   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
///   |                                                               |
///   /                       AV Pairs (variable)                     /
///   |                                                               |
///   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
///   
/// 
/// </summary>
public class NtlmV2ClientChallenge
{
    public const int MinimumLength = 32;
    public const byte StructureVersion = 0x01;

    public byte CurrentVersion { get; set; }
    public byte MaximumSupportedVersion { get; set; }
    public ushort Reserved1 { get; set; }
    public uint Reserved2 { get; set; }
    public DateTime TimeStamp { get; set; }
    public uint Reserved3 { get; set; }
    public byte[] ClientChallenge { get; set; } // 8-byte challenge generated by the client
    public KeyValuePairList<AVPairKey, byte[]> AVPairs { get; set; }

    public NtlmV2ClientChallenge()
    {
        CurrentVersion = StructureVersion;
        MaximumSupportedVersion = StructureVersion;
        ClientChallenge = new byte[8];
        AVPairs = [];
    }

    public NtlmV2ClientChallenge(DateTime timeStamp, byte[] clientChallenge, string domainName, string computerName)
    {
        CurrentVersion = StructureVersion;
        MaximumSupportedVersion = StructureVersion;
        TimeStamp = timeStamp;
        ClientChallenge = clientChallenge;
        AVPairs = new()
        {
            { AVPairKey.NbDomainName, Encoding.Unicode.GetBytes(domainName) },
            { AVPairKey.NbComputerName, Encoding.Unicode.GetBytes(computerName) }
        };
    }

    public NtlmV2ClientChallenge(DateTime timeStamp, byte[] clientChallenge,
        KeyValuePairList<AVPairKey, byte[]> targetInfo)
        : this(timeStamp, clientChallenge, targetInfo, null)
    {
    }

    public NtlmV2ClientChallenge(DateTime timeStamp, byte[] clientChallenge,
        KeyValuePairList<AVPairKey, byte[]> targetInfo, string? spn)
    {
        CurrentVersion = StructureVersion;
        MaximumSupportedVersion = StructureVersion;
        TimeStamp = timeStamp;
        ClientChallenge = clientChallenge;
        AVPairs = targetInfo;
        if (!string.IsNullOrEmpty(spn))
        {
            AVPairs.Add(AVPairKey.TargetName, Encoding.Unicode.GetBytes(spn));
        }
    }

    public NtlmV2ClientChallenge(ReadOnlySpan<byte> buffer)
    {
        CurrentVersion = ByteReader.ReadByte(ref buffer);
        MaximumSupportedVersion = ByteReader.ReadByte(ref buffer);
        Reserved1 = LittleEndianReader.ReadUInt16(ref buffer);
        Reserved2 = LittleEndianReader.ReadUInt32(ref buffer);
        TimeStamp = LittleEndianReader.ReadFileTime(ref buffer);
        ClientChallenge = ByteReader.ReadBytes(ref buffer, 8);
        Reserved3 = LittleEndianReader.ReadUInt32(ref buffer);
        AVPairs = AVPairUtils.ReadAVPairSequence(buffer);
    }

    public byte[] GetBytes()
    {
        var sequenceBytes = AVPairUtils.GetAVPairSequenceBytes(AVPairs);

        var buffer = new byte[28 + sequenceBytes.Length];
        var bufferSpan = buffer.AsSpan();
        ByteWriter.WriteByte(ref bufferSpan, CurrentVersion);
        ByteWriter.WriteByte(ref bufferSpan, MaximumSupportedVersion);
        LittleEndianWriter.WriteUInt16(ref bufferSpan, Reserved1);
        LittleEndianWriter.WriteUInt32(ref bufferSpan, Reserved2);
        LittleEndianWriter.WriteFileTime(ref bufferSpan, TimeStamp);
        ByteWriter.WriteBytes(ref bufferSpan, ClientChallenge);
        LittleEndianWriter.WriteUInt32(ref bufferSpan, Reserved3);
        ByteWriter.WriteBytes(ref bufferSpan, sequenceBytes);
        return buffer;
    }

    /// <summary>
    ///     [MS-NLMP] Page 60, Response key calculation algorithm:
    ///     To create 'temp', 4 zero bytes will be appended to NTLMv2_CLIENT_CHALLENGE
    /// </summary>
    public byte[] GetBytesPadded()
    {
        return [.. GetBytes(), 0, 0, 0, 0];
    }
}